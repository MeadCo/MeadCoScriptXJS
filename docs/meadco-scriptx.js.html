

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>MeadCo.ScriptXJS Library meadco-scriptx.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="style.css">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
             
                <a href="index.html">
                    <h1 class="navbar-item">MeadCo.ScriptXJS</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                 
                    
                        <a
                            class="link user-link "
                            href="https://github.com/MeadCo/MeadCo.ScriptXJS"
                        >
                            Github
                        </a>
                    
                        <a
                            class="link user-link "
                            href="https://www.meadroid.com/Developers/KnowledgeBank/HowToGuides/ScriptXServices/ThenToNow"
                        >
                            Then to now walk through
                        </a>
                    
                        <a
                            class="link user-link "
                            href="https://scriptxprintsamples.meadroid.com"
                        >
                            Samples
                        </a>
                    
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Namespaces</h3><ul><li><a href="MeadCoScriptX.html">MeadCo.ScriptX</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>meadco-scriptx.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Simple wrappers on the MeadCo ScriptX objects 'factory', 'factory.printing' and 'secmgr' with additional helper functions.
 * 
 * The implementation is for use in a browser only, not general runtime javascript environments and the code is necessarily 'old-fashioned' as it may find itself running in old versions of IE.
 *
 * ## Introduction
 * 
 * The library provides two objects within the MeadCo 'namespace':
 * 
 * | Object | Purpose | 
 * |---|---| 
 * | MeadCo.ScriptX | wraps the classic 'factory' (MeadCo.ScriptX.Utils) and factory.printing (MeadCo.ScriptX.Printing) objects and provides useful helper functions for common processes.|
 * | MeadCo.Licensing | wraps the classic 'secmgr' object. |
 *
 * ### MeadCo.ScriptX
 * 
 * The &amp;lt;object /&amp;gt; tag for ScriptX factory is assumed to have an id of 'factory', call MeadCo.ScriptX.Init() (or MeadCo.ScriptX.InitAsync()) to connect the wrappers to underlying implementations - returns true on success.
 *
 * 2 objects will then be available:22
 * 
 * | Object | |
 * |--- |---| 
 * | MeadCo.ScriptX.Utils |  the 'factory' object with all the properties and methods [as documented]{@link https://www.meadroid.com/Developers/KnowledgeBank/TechnicalReference/ScriptXAddOn/factory} |
 * | MeadCo.ScriptX.Printing | the 'factory.printing' object with all the properties and methods [as documented]{@link https://www.meadroid.com/Developers/KnowledgeBank/TechnicalReference/ScriptXAddOn/printing}, e.g. MeadCo.ScriptX.Printing.header = "My Report header". |
 *
 * ### MeadCo.Licensing
 * 
 * The &amp;lt;object /&amp;gt; tag for MeadCo Security Manager is assumed to have an id of 'secmgr', call MeadCo.Licensing.IsLicensed() to test if the licensed is valid for the document and has been installed/accepted.
 * 
 * ## Use with ScriptX.Services
 * 
 * v1.2 and later support working with ScriptX.Services or ScriptX.Add-on and so this librray provides an abstraction and helper functions for working seamlessly with either ScriptX.Addon or ScriptX.Services. This works by
 * utilising the [MeadCo ScriptX.Services Client Library]{@link https://meadco.github.io/ScriptX.Print.Client/} emulation of 'factory' and 'secmgr'. When both libraries are present, on IE 11 with ScriptX.Addon available it will 
 * take priority. On any other browser ScriptX.Services will be used.
 * 
 * @example &lt;caption>Example of initialisation and use of wrappers&lt;/caption>
 *  $(window).on('load', function () {
 *    if ( MeadCo.ScriptX.Init() (
 *    {
 *       $("#info").text("ScriptX version: " + MeadCo.ScriptX.GetComponentVersion("scriptx.factory"));
 *       MeadCo.ScriptX.Printing.header =
 *        "MeadCo's ScriptX&amp;b:&amp;p of &amp;P:&amp;bBasic Printing Sample";
 *      MeadCo.ScriptX.Printing.footer =
 *        "The de facto standard for advanced web-based printing";
 *      MeadCo.ScriptX.Printing.orientation = "landscape";
 *      $("#btnprint").click(function() {
 *          MeadCo.ScriptX.PrintPage(false);
 *   }
 * });
 * 
 * @example &lt;caption>Example of MeadCo.Licensing.IsLicensed()&lt;/caption>
 * if ( MeadCo.Licensing.IsLicensed() ) {
 *  	...
 * }
 * else {
 *    MeadCo.Licensing.ReportError();
 * }
 *
 * @namespace MeadCo.ScriptX
 */

// v1.4.0 and later require a promise polyfill if not implemented in the browser
//  we recommend (and test with) https://github.com/taylorhakes/promise-polyfill
//
// v1.3.0 and later introduce an async model to enable async scenarios with ScriptX.Print Services.
//
// v1.2.0 and later include support for working with ScriptX Services via a polyfill
//  - include meadco-scriptxfactory.js before this file and call MeadCo.ScriptX.Print.HTML.connect() 
//  see https://meadco.github.io/ScriptX.Print.Client/
//
//

// MeadCo.ScriptX - static singleton instances.
//
(function (topLevelNs) {
    "use strict";

    if (typeof topLevelNs["ScriptX"] === "undefined") {
        console.log("intialising new ScriptX package");
        topLevelNs.ScriptX = {};
    }

    var version = "1.8.2-beta01";

    var scriptx = topLevelNs.ScriptX;

    /**
     * Enum to describe the implementation being wrapped : .Addon or .Services
     * 
     * @typedef {number} Connection
     * @enum {Connection}
     * @memberof MeadCo.ScriptX
     * @readonly
     * @property {number} NONE 0 no connection wrapped (initialise not called or failed)
     * @property {number} ADDON 1 ScriptX.Addon is being wrapped
     * @property {number} SERVICE 2 ScriptX.Services is being wrapped
     */
    var enumConnection = {
        NONE: 0,
        ADDON: 1,
        SERVICE: 2
    };

    /**
     * Enum to describe the units used on measurements. These values do match the values used by the MeadCo ScriptX COM Servers. 
     *
     * @typedef {number} MeasurementUnits
     * @enum {MeasurementUnits}
     * @memberof MeadCo.ScriptX
     * @readonly
     * @property {number} DEFAULT 0 use the default at the print server
     * @property {number} MM 2 millimeters  
     * @property {number} INCHES 2 inches
     */
    var enumMeasurementUnits = {
        DEFAULT: 0,
        MM: 1,
        INCHES: 2
    };

    console.log("Initialising MeadCo.ScriptX: " + version);

    // expose enumerations
    scriptx.MeasurementUnits = enumMeasurementUnits;
    scriptx.Connection = enumConnection;
    scriptx.Factory = null;
    scriptx.Printing = null;
    scriptx.Utils = null;

    // for documentation

    /**
     * The discovered connection - NONE, ADDON or SERVICE
     * @memberof MeadCo.ScriptX
     * @readonly 
     */
    var Connector = enumConnection.NONE;

    /**
     * The semver version of this library
    * @memberof MeadCo.ScriptX
    * @readonly
    */
    var LibVersion = version;

    // exposed values.
    scriptx.Connector = enumConnection.NONE;
    scriptx.LibVersion = version;

    /**
    * Performs synchronous initialisation by discovering and connecting to either ScriptX.Addon or
    * ScriptX.Services.
    *
    * With ScriptX.Print Services this will use a synchronous (blocking, deprecated) call to the server
    * 
    * @function Init
    * @memberof MeadCo.ScriptX
    * @returns {boolean} true if initialisation succeeded and implementations of the MeadCo ScriptX factory and printing objects are available, false if failed
    */
    scriptx.Init = function () {
        if (scriptx.Printing === null) {
            console.log("scriptx.Init()");
            if (findFactory(true) !== null) {
                // if we are connected to the ScriptX.Print implementation
                // then check it has connected.
                if (typeof scriptx.Printing.PolyfillInit === "function") {
                    console.log("found ScriptX.Print Services");
                    console
                        .warn("Synchronous initialisation is deprecated - please update to MeadCo.ScriptX.InitAsync().");
                    if (!scriptx.Printing.PolyfillInit()) {
                        console.log("**warning** polyfill failed.");
                        scriptx.Printing = null;
                        scriptx.Connector = scriptx.Connection.NONE;
                    } else {
                        scriptx.Connector = scriptx.Connection.SERVICE;
                    }
                } else {
                    scriptx.Connector = scriptx.Connection.ADDON;
                }
            } else {
                console.log("** Warning -- no factory **");
            }
        }

        return scriptx.Printing !== null;
    };

    /**
    * Performs asynchronous initialisation by discovering and connecting to either ScriptX.Addon or
    * ScriptX.Services.
    *
    * @function InitAsync
    * @memberof MeadCo.ScriptX
    * @returns {Promise} 
    */
    scriptx.InitAsync = function () {
        var prom;

        console.log("scriptx.InitAsync()");
        if (scriptx.Printing === null) {
            console.log("unknown state ...");
            prom = new Promise(function (resolve, reject) {
                console.log("looking for state ...");
                if (findFactory(true) !== null) {
                    console.log("look for Polyfill ..");
                    if (typeof scriptx.Printing.PolyfillInitAsync === "function") {
                        console.log("found async ScriptX.Print Services");
                        scriptx.Printing.PolyfillInitAsync(function () {
                            scriptx.Connector = scriptx.Connection.SERVICE;
                            console.log("scriptx.InitAsync() calling resolve ...");
                            resolve(scriptx.Connector);
                        }, reject);
                    } else {
                        scriptx.Connector = scriptx.Connection.ADDON;
                        console.log("no polyfill, using add-on");
                        resolve(scriptx.Connector);
                    }
                } else {
                    console.log("** Warning -- no factory **");
                    reject("Unable to find a ScriptX 'factory' object.");
                }
            });
        } else {
            prom = new Promise(function (resolve, reject) {
                resolve(scriptx.Connector);
            });
        }

        return prom;
    };

    /**
    *  Initialises the library and ensures that the installed version is at least some version. If ScriptX is available but not the required version an alert dialog is displayed.
    *  
    * @function InitWithVersion
    * @memberof MeadCo.ScriptX
    * @param {string} strVersion minimum required version number (e.g. "7.1.2.65")
    * @returns {boolean} true if initialisation succeeded and implementations of the MeadCo ScriptX factory and printing objects are available at the required version of higher, false if failed
    * @deprecated from version 1.8.0
    */
    scriptx.InitWithVersion = function (strVersion) {
        var bok = false;
        if (scriptx.Init()) {
            bok = scriptx.IsVersion(strVersion);
            if (!bok)
                alert("ScriptX v" + strVersion + " or later is required.\nYou are using a previous version and errors may occur.");
        }
        return bok;
    };

    /**
    * @function Version
    * @memberof MeadCo.ScriptX
    * 
    * @returns {string} the installed version number of ScriptX (if services is in use then returns the version of ScriptX.Addon being emulated).
    *
    * */
    scriptx.Version = function () {
        return scriptx.GetComponentVersion("ScriptX.Factory");
    };

    /**
    * @function IsVersion
    * @memberof MeadCo.ScriptX
    * @param {string} strVersion
    * @returns {boolean} true if the installed version is at least strVersion where strVersion is a dotted version number (e.g. "7.1.2.65")
    */
    scriptx.IsVersion = function (strVersion) {
        return scriptx.IsComponentVersion("ScriptX.Factory", strVersion);
    };

    /**
     * @function IsServices
     * @memberof MeadCo.ScriptX
     * @param {string} strVersion
     * @returns {boolean} true if ScriptX.Services is/will be used
     *
     */
    scriptx.IsServices = function () {
        var connection = scriptx.Connector;
        // If init() not yet called, try a guess. 
        //
        // This relies on the Add-on and the .services client scripts are all included before this script.
        // But, we do not want to perform a full init here because connection data might not have been specified
        console.log("IsServices() on connector: " + connection);
        if (connection === enumConnection.NONE) {
            var p = findFactory(false);
            if (p !== null) {
                connection = typeof p.PolyfillInit === "function" ? enumConnection.SERVICE : enumConnection.ADDON;
            }
            else {
                // assume service will be used, for sure the Add.on isnt here
                connection = enumConnection.SERVICE;
            }
        }

        return connection === enumConnection.SERVICE;
    };

    /**
     * If services is in use, returns the version of the services server. If addon is in use returns ""
     * 
     * Requires services 2.9 or later, earlier versions will return the client library version (1.x)
     * 
     * @function ServicesVersion
     * @memberof MeadCo.ScriptX
     * @returns {string}
     * */

    scriptx.ServicesVersion = function () {
        if (scriptx.IsServices()) {
            return scriptx.GetComponentVersion("scriptx.services");
        }

        return "";
    };

    /**
     * @function IsServicesVersion
     * @memberof MeadCo.ScriptX
     * @param {string} strVersion
     * @returns {boolean} true if the services server in use is at least strVersion where strVersion is a dotted version number (e.g. "7.1.2.65")
     */
    scriptx.IsServicesVersion = function (strVersion) {
        if (scriptx.IsServices()) {
            return scriptx.IsComponentVersion("scriptx.services", strVersion);
        }

        return false;
    };

    /**
    * Print the current document, with optional prompting (no prompt in the internetzone requires a license)
    * @function PrintPage
    * @memberof MeadCo.ScriptX
    * @param {boolean} [bPrompt=true] bPrompt True if a dialog is to prompt the user to confirm the print
    * @returns {boolean} true if print was started, otherwise false
    * @deprecated from 1.4 as the return value will be wrong for service since dialogs are async. Use PrintPage2 if the return value matters
    */
    scriptx.PrintPage = function (bPrompt) {
        if (scriptx.Init())
            return scriptx.Printing.Print(bPrompt);
        return false;
    };

    /**
    * Print the current document, with optional prompting (no prompt in the internetzone requires a license)
    * @function PrintPage2
    * @memberof MeadCo.ScriptX
    * @param {boolean} [bPrompt=true] bPrompt
    * @returns {Promise} Promise object represents boolean with value true if the print was started
    */
    scriptx.PrintPage2 = function (bPrompt) {
        return new Promise(function (resolve, reject) {
            if (scriptx.Init()) {
                if (scriptx.Connector === scriptx.Connection.SERVICE) {
                    scriptx.Printing.Print(bPrompt, null, function (dlgOk) {
                        resolve(dlgOk);
                    });

                } else {
                    resolve(scriptx.Printing.Print(bPrompt));
                }
            }
            else
                reject();
        });
    };

    /**
     * Opens a preview of the printed current document (page).
     * @function PreviewPage
     * @memberof MeadCo.ScriptX
     * */
    scriptx.PreviewPage = function () {
        if (scriptx.Init()) {
            scriptx.Printing.Preview();
        }
    };

    // PrintFrame
    // Print the content of the *named* frame with optional prompting (no prompt in the internetzone requires a license)

    /**
    * Print the content of the frame, with optional prompting (no prompt in the internetzone requires a license)
    * @function PrintFrame
    * @memberof MeadCo.ScriptX
    * @param {string|object} frame The frame object or the name of the frame to be printed.
    * @param {boolean} [bPrompt=true] bPrompt True if a dialog is to prompt the user to confirm the print
    * @returns {boolean} true if print was started, otherwise false
    * @deprecated from 1.4 as the return value will be wrong for service since dialogs are async. Use PrintFrame2 if the return value matters
     */
    scriptx.PrintFrame = function (frame, bPrompt) {
        if (scriptx.Init())
            return scriptx.Printing.Print(bPrompt, typeof (frame) === "string" ? (scriptx.IsVersion("6.5.439.30") ? frame : eval("window." + frame)) : frame);
        return false;
    };

    /**
    * Print the content of the frame, with optional prompting (no prompt in the internetzone requires a license)
    * @function PrintFrame2
    * @memberof MeadCo.ScriptX
    * @param {string|object} frame The frame object or the name of the frame to be printed.
    * @param {boolean} [bPrompt=true] bPrompt True if a dialog is to prompt the user to confirm the print
    * @returns {Promise} Promise object represents boolean with value true if the print was started
    */
    scriptx.PrintFrame2 = function (frame, bPrompt) {
        return new Promise(function (resolve, reject) {
            if (scriptx.Init()) {
                if (scriptx.Connector === scriptx.Connection.SERVICE) {
                    scriptx.Printing.Print(bPrompt, frame, function (dlgOk) {
                        resolve(dlgOk);
                    });

                } else {
                    resolve(scriptx.PrintFrame(frame, bPrompt));
                }
            }
            else
                reject();
        });
    };

    /**
     * Opens a preview of the printed frame).
     * @function PreviewPage
     * @memberof MeadCo.ScriptX
     * @param {string|object} frame The frame object or the name of the frame to be printed.
     */
    scriptx.PreviewFrame = function (frame) {
        if (scriptx.Init())
            scriptx.Printing.Preview(typeof (frame) === "string" ? (scriptx.IsVersion("6.5.439.30") ? frame : eval("window." + frame)) : frame);
    };


    // BackgroundPrintURL - requires license
    // Background download and print the document from the URL. optional print prompt before queuing the print
    // and optional callback function to monitor progress.
    // [optional] fnCallback(status,statusData,data)
    // [optional] data
    // 
    var jobIndex = 1;
    scriptx.BackgroundPrintURL = function (sUrl, bPrompt, fnCallback, data) {
        if (scriptx.Init()) {
            if (typeof fnCallback === "undefined") {
                fnCallback = progressMonitor;
            }
            if (typeof data === "undefined") {
                data = "Job " + jobIndex++;
            }
            return scriptx.Printing.PrintHTMLEx(sUrl, bPrompt, fnCallback, data);
        }
        return false;
    };

    scriptx.BackgroundPrintURL2 = function (sUrl, bPrompt, fnCallback, data) {
        return new Promise(function (resolve, reject) {
            if (scriptx.Init()) {

                if (typeof fnCallback === "undefined") {
                    fnCallback = progressMonitor;
                }
                if (typeof data === "undefined") {
                    data = "Job " + jobIndex++;
                }

                if (scriptx.Connector === scriptx.Connection.SERVICE) {
                    scriptx.Printing.PrintHTMLEx(sUrl, bPrompt, fnCallback, data, function (dlgOk) {
                        resolve(dlgOk);
                    });
                } else {
                    resolve(scriptx.Printing.PrintHTMLEx(sUrl, bPrompt, fnCallback, data));
                }
            }
            else
                reject();
        });
    };


    // BackgroundPrintHTML - requires license
    // Background print the html document contained in the string. The document must be complete and well formed.
    // All resource references in the HTML must be fully qualified unless a base element is included.
    scriptx.BackgroundPrintHTML = function (sHtml, fnCallback, data) {
        return scriptx.BackgroundPrintURL("html://" + sHtml, false, fnCallback, data);
    };

    // Direct/RAW printing - requires a license 

    // Send the given string (e.g. ZPL) directly to the printer as a byte stream 
    scriptx.DirectPrintString = function (sPrinterName, sData) {

        if (scriptx.Init()) {
            var rawPrinter = scriptx.Factory.rawPrinting;

            rawPrinter.printer = sPrinterName;
            rawPrinter.printString(sData);
        }
    };

    // Download content from the url and send its contents (e.g. ZPL) directly to the printer as a byte stream 
    scriptx.DirectPrintDocument = function (sPrinterName, sUrl) {

        if (scriptx.Init()) {
            var rawPrinter = scriptx.Factory.rawPrinting;

            rawPrinter.printer = sPrinterName;
            rawPrinter.printDocument(scriptx.Factory.baseURL(sUrl));
        }
    };

    // Page/Print Setup - these will work with both add-on and service
    // but return value will be wrong for service since dialogs are async
    // If the return value matters use xxxx2 api below.
    scriptx.PageSetup = function () {
        if (scriptx.Init())
            return scriptx.Printing.PageSetup();
        return false;
    };

    scriptx.PrintSetup = function () {
        if (scriptx.Init())
            return scriptx.Printing.PrintSetup();
        return false;
    };

    // Promise versions to work with async dialogs with service
    // These work with both add-on and service.
    //
    scriptx.PageSetup2 = function () {
        return new Promise(function (resolve, reject) {
            if (scriptx.Init()) {

                if (scriptx.Connector === scriptx.Connection.SERVICE) {
                    scriptx.Printing.PageSetup(function (dlgOK) {
                        if (dlgOK)
                            resolve();
                        else
                            reject();
                    });
                } else {
                    if (scriptx.Printing.PageSetup()) {
                        resolve();
                    } else {
                        reject();
                    }
                }
            }
            else
                reject();
        });
    };

    scriptx.PrintSetup2 = function () {
        return new Promise(function (resolve, reject) {
            if (scriptx.Init()) {
                if (scriptx.Connector === scriptx.Connection.SERVICE) {
                    scriptx.Printing.PrintSetup(function (dlgOK) {
                        if (dlgOK)
                            resolve();
                        else
                            reject();
                    });
                } else {
                    if (scriptx.Printing.PrintSetup()) {
                        resolve();
                    } else {
                        reject();
                    }
                }
            }
            else
                reject();
        });
    };


    // WaitForSpoolingComplete 
    //
    // A wrapper to hide differences between Add-on and ScriptX.Print Services 
    //
    scriptx.WaitForSpoolingComplete = function () {
        if (scriptx.Connector === scriptx.Connection.SERVICE) {
            return new Promise(function (resolve, reject) {
                scriptx.Printing.WaitForSpoolingComplete(-1, resolve);
            });
        }

        return new Promise(function (resolve, reject) {
            window.setTimeout(function () {
                scriptx.Printing.WaitForSpoolingComplete();
                resolve();
            }, 1);
        });

    };

    // HasOrientation
    // Returns true if the 'orientation' property is available, otherwise the 'portrait' property must be used.
    //
    scriptx.HasOrientation = function () {
        return scriptx.IsComponentVersion("ScriptX.Factory", "7.0.0.1");
    };

    // GetAvailablePrinters - requires license
    // returns an array of the names of the printers on the system
    //
    scriptx.GetAvailablePrinters = function () {
        var plist = new Array();
        var name;
        if (scriptx.Init()) {
            try {
                for (var i = 0; (name = scriptx.Printing.EnumPrinters(i)).length > 0; i++) {
                    plist.push(name);
                }
            } catch (e) {
                var x = 1;
            }
        }
        return plist;
    };

    // GetComponentVersion
    // returns the version number of a COM component - compatible with v7.0 and earlier implementation. (ScriptX v7.1 has an easier to use implementation)
    scriptx.GetComponentVersion = function (sComponent) {
        var a = new Object();
        var b = new Object();
        var c = new Object();
        var d = new Object();
        var s = "(Not installed)";

        try {
            scriptx.Utils.GetComponentVersion(sComponent, a, b, c, d);
            s = a[0] + "." + b[0] + "." + c[0] + "." + d[0];
        }
        catch (e) {
            var x = 1;
        }

        return s;
    };

    scriptx.ScriptXVersion = function () {
        return scriptx.GetComponentVersion("ScriptX.Factory");
    };

    scriptx.SecurityManagerVersion = function () {
        return scriptx.GetComponentVersion("MeadCo.SecMgr");
    };

    // IsComponentVersion
    // Returns true if the installed version of a COM component is at least the given version
    scriptx.IsComponentVersion = function (strComponentName, strVersionRequired) {
        return compareVersions(scriptx.GetComponentVersion(strComponentName), strVersionRequired);
    };

    // Private implementation

    // findFactory
    //
    // find an instance of 'factory', either the add-on or polyfill, optionally hook up to
    // the module and return the instance of the printing object (in Add-on this creates the object)
    function findFactory(bRecord) {
        var f = window.factory || document.getElementById("factory"); // we assume the &lt;object /> has an id of 'factory'
        if (f &amp;&amp; typeof f.object !== "undefined" &amp;&amp; f.object !== null) {
            if (bRecord) {
                scriptx.Factory = f;
                scriptx.Utils = f.object;
                scriptx.Printing = f.printing;
            }
            console.log("found a scriptx factory");
            return f.printing;
        }
        return null;
    }

    // compareVersions
    //
    // Return true if v1 is later than or equal to v2
    //
    function compareVersions(v1, v2) {
        var a = v1.split(".");
        var b = v2.split(".");
        var i;

        if (a.length !== b.length)
            return false;

        for (i = 0; i &lt; a.length; i++) {
            a[i] = parseInt(a[i]);
            b[i] = parseInt(b[i]);
        }

        if (a[0] > b[0])
            return true;

        if (a[0] >= b[0] &amp;&amp; a[1] > b[1])
            return true;

        if (a[0] >= b[0] &amp;&amp; a[1] >= b[1] &amp;&amp; a[2] > b[2])
            return true;

        if (a[0] >= b[0] &amp;&amp; a[1] >= b[1] &amp;&amp; a[2] >= b[2] &amp;&amp; a[3] >= b[3])
            return true;

        return false;
    }

    // exemplar PrintHTMLEx callback that does nothing (well, it logs to the console)

    // statusUpdate
    // Display status and/or its description
    function statusUpdate(status, txt) {
        console.log("PrintHTML Queue status: " + status + " => " + txt);
    }

    // progressMonitor
    // callback from PrintHTMLEx / BatchPrintPDFEx
    function progressMonitor(status, statusData, callbackData) {
        switch (status) {
            case 1:
                // v8.2 / 10.2 will passback the queue mode 
                statusUpdate(status, "Request to print has been queued for: " + callbackData + (typeof statusData === "undefined" ? "" : ", " + statusData));
                break;

            case 2:
                statusUpdate(status, "Print job started on: " + callbackData);
                break;

            case 3:
                statusUpdate(status, "Downloading " + statusData + " for: " + callbackData);
                break;

            case 4:
                statusUpdate(status, "Download completed to " + statusData + " for: " + callbackData);
                break;

            case 5:
                statusUpdate(status, "Printing has started for: " + callbackData);
                break;

            case 6:
                statusUpdate(status, "Job complete for: " + callbackData);
                break;

            case 7:
                statusUpdate(status, "Job paused for: " + callbackData);
                break;

            case 8:
                statusUpdate(status, "PDF is being printed: " + statusData + " for: " + callbackData);
                break;

            case -1:
                statusUpdate(status, "Print failed because of an error: [" + statusData + "] for: " + callbackData);
                break;

            case -2:
                statusUpdate(status, "Printing has been abandoned for: " + callbackData);
                break;
        }
    }

}(window.MeadCo = window.MeadCo || {}));

// MeadCo.Licensing - singleton
//
(function (topLeveNs) {
    "use strict";

    topLeveNs.Licensing = {};

    var licensing = topLeveNs.Licensing;

    licensing.Connection = {
        NONE: 0,
        ADDON: 1,
        SERVICE: 2
    };

    licensing.LibVersion = "1.8.1";
    licensing.LicMgr = null;
    licensing.Connector = licensing.Connection.NONE;

    licensing.Init = function () {
        if (licensing.LicMgr === null) {
            console.log("licensing.Init()");
            if (findSecMgr()) {
                // what have we connected to?

                // if we are connected to the ScriptX.Print implementation
                // then check it has connected.
                if (typeof licensing.LicMgr.PolyfillInit === "function") {
                    console.log("found secmgr services");
                    console
                        .warn("Synchronous initialisation is deprecated - please update to MeadCo.Licensing.InitAsync().");
                    if (!licensing.LicMgr.PolyfillInit()) {
                        console.log("**warning** polyfill failed.");
                        licensing.LicMgr = null;
                        licensing.Connector = licensing.Connection.NONE;
                    } else {
                        licensing.Connector = licensing.Connection.SERVICE;
                    }
                } else {
                    licensing.Connector = licensing.Connection.ADDON;
                }
            } else {
                console.log("** Warning -- no secmgr **");
            }
        }
        return licensing.LicMgr !== null &amp;&amp; typeof (licensing.LicMgr.result) !== "undefined";
    };

    licensing.InitAsync = function () {
        var prom;

        console.log("licensing.InitAsync()");

        return new Promise(function (resolve, reject) {
            if (licensing.LicMgr === null) {
                if (findSecMgr()) {
                    console.log("Look for polyfill");
                    if (typeof licensing.LicMgr.PolyfillInitAsync === "function") {
                        console.log("Found async secmgr services");
                        licensing.LicMgr.PolyfillInitAsync(function () {
                            console.log("polyfill initialised ok");
                            licensing.Connector = licensing.Connection.SERVICE;
                            resolve();
                        }, reject);
                    } else {
                        console.log("No polyfill, using as add-on");
                        licensing.Connector = licensing.Connection.ADDON;
                        resolve();
                    }
                } else {
                    console.log("** Warning -- no secmgr **");
                    reject();
                }
            } else {
                if (licensing.Connector === licensing.Connection.NONE) {
                    reject();
                } else {
                    resolve();
                }
            }
        });

    };

    // IsLicensed
    // Returns true if the document is licensed and advanced functionality will be available
    licensing.IsLicensed = function () {

        if (licensing.Init()) {
            var l = licensing.LicMgr.License;
            return licensing.LicMgr.result === 0 &amp;&amp; licensing.LicMgr.validLicense;
        }

        console.log("WARNING :: MeadCo.Licensing.Init() failed so IsLicensed will return false.");
        return false;
    };

    // IsLicensedAsync
    // Returns a promise with a resolve of the loaded license detail
    //
    licensing.IsLicensedAsync = function () {
        return new Promise(function (resolve, reject) {
            licensing.InitAsync()
                .then(function () {
                    if (typeof licensing.LicMgr.GetLicenseAsync === "function") {
                        licensing.LicMgr.GetLicenseAsync(resolve, reject);
                    } else {
                        resolve(licensing.LicMgr.License);
                    }
                })
                .catch(function () { reject(lookupError()); });
        });
    };


    licensing.ErrorMessage = function () {
        console.log("licensing.ErrorMessage - MeadCo Security Manager reports licensed: " + this.IsLicensed());
        return !licensing.IsLicensed() ? lookupError() : "";
    };

    // ReportError
    // Displays an alert box with details of any licensing error with any given message appended.
    licensing.ReportError = function (msg) {

        var errMsg = licensing.ErrorMessage();
        if (errMsg !== "") {
            reportError(errMsg, msg);
        }
    };

    // private implementation
    // ErrorMessage
    // returns the error message that describes why licensing failed. returns emoty string if there was no error.
    var errorLicenseMsgs = new Array("Unable to locate the MeadCo License Manager object - the component may not be installed.",
        "The license for this site is not valid.",
        "The license for this site not installed on this machine.",
        "The license for this site has not been accepted by the user.",
        "There was an error loading the license. ",
        "Unable to connect to ScriptX.Services license management."
    );

    function lookupError() {
        var eIndex = -1;
        var msgSuffix = "";

        if (licensing.LicMgr !== null) {
            console.log("license result: " + licensing.LicMgr.result + " valid: " + licensing.LicMgr.validLicense);

            switch (licensing.LicMgr.result) {
                case 0:
                    if (!licensing.LicMgr.validLicense)
                        eIndex = 1;
                    break;

                case 5: // scriptx.print service error
                    eIndex = 5;
                    break;

                case 1:
                    // magic value: this only applies if path param not
                    // not given - .result==1 => license not installed
                    eIndex = 2;
                    break;

                case -2147220500:
                    // magic value: this only applies if a path
                    // was given and the license is valid and was
                    // displayed to the user for acceptance - 
                    // .result == -2147220500 => the user clicked cancel on the dialog
                    eIndex = 3;
                    break;

                // some other error, e.g. download failure - this will
                // have already been displayed to the user in an error box.
                // we could be here in the path given or not given cases if there
                // was an error such as reading the registry, though such errors
                // are unlikely.
                default:
                    eIndex = 4;
                    msgSuffix = "\nLicense manager reported error code: 0x" + (0x100000000 + licensing.LicMgr.result).toString(16).toUpperCase();
                    break;
            }

        } else {
            eIndex = 0;
        }

        return (eIndex >= 0) ? errorLicenseMsgs[eIndex] + msgSuffix : "";

    }

    function reportError(eMsg) {
        var msg = eMsg;
        for (var i = 1; i &lt; arguments.length; i++) {
            if (arguments[i])
                msg += "\n\n" + arguments[i];
        }
        alert(msg);
    }

    // try to find the Security Manager add-on on the page.
    // 
    function findSecMgr() {
        var l = window.secmgr || document.getElementById("secmgr");  // we assume the &lt;object /> has an id of 'secmgr'
        if (l &amp;&amp; l.object !== null &amp;&amp; typeof l.object !== "undefined") {
            licensing.LicMgr = l.object;
            console.log("Found a secmgr: " + (typeof licensing.LicMgr.result !== "undefined"));
            return typeof (licensing.LicMgr.result) !== "undefined";
        }
        return false;
    }

}(window.MeadCo = window.MeadCo || {}));

</code></pre>
        </article>
    </section>




            </div>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/search.js"> </script>

</body>
</html>
